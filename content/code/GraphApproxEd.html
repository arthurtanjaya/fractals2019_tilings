<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <meta name="description" content="Cornell SPUR 2019 Analysis on Fractals: Tilings on the Sierpinski gasket and its blow-ups">
        <meta name="referrer" content="no-referrer">
        <meta name="theme-color" content="#b31b1b">
        <meta http-equiv="content-security-policy" content="script-src 'self'; object-src 'none'">
        <title>
            GraphApprox.m - SPUR 2019: Tilings on SG
        </title>
        <link rel="stylesheet" href="../../css/main.css">
        <meta name="generator" content="MATLAB 9.6">
    </head>

    <body>
        <nav>
            <div class="topnav">
                <a href="../../index.html">Home</a>
                <a href="index.html">MATLAB Code</a>
                <a href="../details/index.html">Details</a>
                <a href="../talks/index.html">Talks</a>
            </div>
        </nav>
        <center>
            <h1>
                GraphApprox.m
            </h1>
        </center>
        <!-- Begin auto-generated content -->
        <div class="content">

            <pre class="codeinput">
<span class="keyword">classdef</span> GraphApprox
    <span class="comment">%GRAPHAPPROX Graph Approximation of SG</span>

    <span class="keyword">properties</span> (SetAccess = private)
        level     <span class="comment">% Level of fineness (this is m in \Gamma_m)</span>
        vertices  <span class="comment">% Row vector of vertices in the graph</span>
        edges     <span class="comment">% Row vector of edges in the graph</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span>

        <span class="keyword">function</span> self = GraphApprox(level)
            <span class="comment">%GRAPHAPPROX Construct an instance of this class</span>
            <span class="comment">%   Input should be an int; no error checking (yet?)</span>

            self.level = level;

            <span class="comment">% Construct vertices</span>
            <span class="comment">% Construct V_0</span>
            Z = zeros(1, level+1);  <span class="comment">% Off-by-one ugh.</span>
            self.vertices = [Vertex(Z) Vertex(Z+1) Vertex(Z+2)];
            <span class="keyword">for</span> i = 2:level+1
                <span class="comment">% Construct V_{i-1} from V_{i-2}</span>
                new_vertices = Vertex.empty(0, 3^(i-1));
                count = 1;  <span class="comment">% To index new_vertices</span>

                <span class="comment">% Instead of iterating over the vertices in V_{i-2},</span>
                <span class="comment">% we iterate over the i-2 cells instead</span>
                <span class="comment">% Cell addressing is unique, so no problems here</span>
                cell_addresses = CartesianProd([0, 1, 2], i-2);
                <span class="keyword">for</span> cell_index = 1:3^(i-2)
                    <span class="keyword">if</span> i == 2
                        cell = [];  <span class="comment">% Annoying edge case</span>
                    <span class="keyword">else</span>
                        cell = cell_addresses(cell_index, :);
                    <span class="keyword">end</span>
                    <span class="keyword">for</span> head = 0:2
                        address = [head cell];
                        <span class="comment">% Pad the end of address with the vertex bit</span>
                        address(end+1:level+1) = head;
                        <span class="comment">% Assign addresses in a cyclic fashion</span>
                        new_address = [address(1:i-1) <span class="keyword">...</span>
                                       mod(address(i)+1, 3) <span class="keyword">...</span>
                                       address(i+1:end)];
                        new_vertices(count) = Vertex(new_address);
                        count = count + 1;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                self.vertices = [self.vertices new_vertices];  <span class="comment">% Save updates</span>
            <span class="keyword">end</span>

            <span class="comment">% Construct edges</span>
            <span class="comment">% Two vertices share an edge iff they are in the same m-cell</span>
            <span class="comment">% Can postpone this, because we can just count neighbors then</span>
            <span class="comment">% divide by 2</span>
            self.edges = 0;

        <span class="keyword">end</span>

        <span class="keyword">function</span> draw(self, side)
            <span class="comment">%DRAW Draws the graph in xy-plane</span>
            <span class="comment">%   side controls the side length of the bounding triangle</span>
            <span class="comment">%   Assumes that a figure window is already open and hold is on</span>
            <span class="comment">% Draw vertices</span>
            <span class="keyword">for</span> vertex = self.vertices
                vertex.draw(side)
            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre>

            <p class="footer">
                <br>
                <a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a>
                <br>
            </p>
        </div>
        <!-- End auto-generated content -->
    </body>

</html>
