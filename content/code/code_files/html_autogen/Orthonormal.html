
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Orthonormal</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-07-25"><meta name="DC.source" content="Orthonormal.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> Orthonormal

    <span class="keyword">methods</span>(Static)
        <span class="keyword">function</span> check = Test(spectrum, details)
            <span class="comment">%TEST(s,d) returns 1 if the set of functions s (formatted as a result</span>
            <span class="comment">%of functions below) is an orthogonal spectrum with the given</span>
            <span class="comment">%eigenvalues</span>
            mat = double(spectrum{1}(spectrum{3}, 1:end)'*spectrum{1}(spectrum{3}, 1:end));
            <span class="comment">%orth = norm(mat - eye(length(spectrum{3}))) &lt; 0.1;</span>
            orth = norm(mat - diag(diag(mat))) &lt; 0.1 &amp;&amp; rank(mat) == length(mat);
            eigen = EF.EigenfunctionsCheck(spectrum{1}', spectrum{2}');
            <span class="keyword">if</span> details
                disp([<span class="string">"orthogonal:"</span>,orth])
                disp(mat)
                disp([<span class="string">"eigenfunctions:"</span>, eigen])
            <span class="keyword">end</span>
            check = orth &amp;&amp; eigen;
        <span class="keyword">end</span>

        <span class="comment">%the spectrum searching functions below have the same</span>
        <span class="comment">%specifications as FindSpectrum</span>
        <span class="comment">%choose set of eigenvalues randomly, solve</span>
        <span class="keyword">function</span> result = FindSpectrum(basis, tile, limit, numerical, varargin)
            <span class="comment">%FINDSPECTRUM(b, t, l, n) returns an orthogonal spectrum of the</span>
            <span class="comment">%subset (i.e., set of points) t of the  SG approximations given by b.</span>
            <span class="comment">%l specifies the number of attempts to solve for the spectrum.</span>
            <span class="comment">%If n is set to true, equations are solved numerically.</span>
            <span class="comment">%The output is a cell array where the first entry conatins the</span>
            <span class="comment">%matrix of eigenfunctions, the second enrty is the row vector</span>
            <span class="comment">%of eigenvalues, the third entry is t.</span>
            w = waitbar(0,mat2str(tile));
            <span class="keyword">if</span> numerical
                digits(4)
            <span class="keyword">end</span>
            dim = length(basis.eigenvalues);
            sdim = length(tile);
            syms <span class="string">P</span> <span class="string">[dim dim]</span>;
            assume(P, <span class="string">'real'</span>)
            indep = ones([dim, dim]);
            <span class="keyword">for</span> i = 1:dim
                <span class="keyword">for</span> j = 1 : i
                    <span class="keyword">if</span> basis.eigenvalues(i) ~= basis.eigenvalues(j)
                        indep(i,j) = 0;
                        indep(j,i) = 0;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            new = (basis.x)*(P.*indep);
            <span class="keyword">for</span> n = 1:limit
                waitbar(n/limit,w);
                chosen = randperm(dim, sdim);
                subnew = new(tile, chosen);
                conditions = [];
                <span class="keyword">if</span> nargin == 5
                    syms <span class="string">u</span> <span class="string">[dim+3 1]</span>;
                    <span class="keyword">for</span> k = 1:sdim
                        conditions = [conditions,subs(varargin{1}, u, new(1:end,chosen(k)))];
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> numerical
                    eqa = vpa(subnew'*subnew == eye(sdim));
                    sol = vpasolve([reshape(eqa, [1, sdim^2]), conditions]);
                <span class="keyword">else</span>
                    eqa = vpa(simplify(subnew'*subnew == eye(sdim)));
                    sol = solve([reshape(eqa, [1, sdim^2]),conditions]);
                <span class="keyword">end</span>
                resP = zeros([dim dim]);
                <span class="keyword">for</span> i = 1 : dim
                    <span class="keyword">for</span> j = 1 : dim
                        <span class="keyword">if</span> isfield(sol, strcat(<span class="string">'P'</span>,int2str(i),<span class="string">'_'</span>,int2str(j))) &amp;&amp; not(isempty(sol.(strcat(<span class="string">'P'</span>,int2str(i),<span class="string">'_'</span>,int2str(j)))))
                            resP(i,j) = subs(sol.(strcat(<span class="string">'P'</span>,int2str(i),<span class="string">'_'</span>,int2str(j)))(1,1), P, zeros([dim dim]));
                        <span class="keyword">else</span>
                            resP(i, j) = 0;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> resP == zeros([dim dim])
                    <span class="keyword">continue</span>
                <span class="keyword">else</span>
                    orthB = (basis.x)*(resP.*indep);
                    orth = orthB(1:end,chosen);
                    eigenvalues = basis.eigenvalues(chosen);
                    result = {orth, eigenvalues, tile};
                    digits(32)
                    close(w);
                    <span class="keyword">return</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            digits(32)
            result = {};
            close(w);
        <span class="keyword">end</span>

        <span class="comment">%same but with parallel</span>
        <span class="keyword">function</span> result = FindSpectrumPar(basis, tile, limit,numerical)
            <span class="keyword">if</span> numerical
                digits(4)
            <span class="keyword">else</span>
            digits(32)
            <span class="keyword">end</span>
            results = [];
            dim = length(basis.eigenvalues);
            sdim = length(tile);
            indep = ones([dim, dim]);
            <span class="keyword">for</span> i = 1:dim
                <span class="keyword">for</span> j = 1 : i
                    <span class="keyword">if</span> basis.eigenvalues(i) ~= basis.eigenvalues(j)
                        indep(i,j) = 0;
                        indep(j,i) = 0;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            syms <span class="string">P</span> <span class="string">[dim dim]</span>;
            assume(P, <span class="string">'real'</span>)
            new = (basis.x)*(P.*indep);
            tilenew = new(tile, 1:end);
            eqa = vpa(simplify(tilenew'*tilenew == eye(dim)));
            <span class="keyword">parfor</span> n = 1:limit
                chosen = randperm(dim, sdim);
                subeqa = eqa(chosen, chosen);
                <span class="keyword">if</span> numerical
                    sol = vpasolve(reshape(subeqa, [1, sdim^2]));
                <span class="keyword">else</span>
                    sol = solve(reshape(subeqa, [1, sdim^2]));
                <span class="keyword">end</span>
                resP = zeros([dim dim]);
                <span class="keyword">for</span> i = 1 : dim
                    <span class="keyword">for</span> j = 1 : dim
                        <span class="keyword">if</span> isfield(sol, strcat(<span class="string">'P'</span>,int2str(i),<span class="string">'_'</span>,int2str(j))) &amp;&amp; not(isempty(sol.(strcat(<span class="string">'P'</span>,int2str(i),<span class="string">'_'</span>,int2str(j)))))
                            vary = symvar(sol.(strcat(<span class="string">'P'</span>,int2str(i),<span class="string">'_'</span>,int2str(j)))(1,1))
                            l = length(vary)
                            resP(i,j) = subs(sol.(strcat(<span class="string">'P'</span>,int2str(i),<span class="string">'_'</span>,int2str(j)))(1,1), vary, zeros([1 l]));<span class="comment">%sol.(strcat('P',int2str(i),'_',int2str(j)))(1,1)</span>
                        <span class="keyword">else</span>
                            resP(i, j) = 0;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> resP == zeros([dim dim])
                    <span class="keyword">continue</span>
                <span class="keyword">else</span>
                    orthB = (basis.x)*(resP.*indep);
                    orth = orthB(1:end,chosen);
                    eigenvalues = basis.eigenvalues(chosen);
                    result = {orth, eigenvalues, tile};
                    results = [results,{result}];
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            digits(32)
            <span class="keyword">if</span> not(isempty(results))
                result = results(1);
                result = result{1};
            <span class="keyword">else</span>
                result = {};
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">%try adding vetors one by one choosing random eigenvalue each time</span>
        <span class="keyword">function</span> result = Spectrum(basis, tile, limit)
            [npts, ~] = size(basis.x);
            dim = length(tile);
            result{3} = tile;
            <span class="keyword">for</span> i = 1:limit
                evunique = unique(basis.eigenvalues);
                result{1} = zeros([npts, dim]);
                result{2} = zeros([1 dim]);
                curr = 0;
                <span class="keyword">while</span> not(isempty(evunique))
                    idx = randi(length(evunique));
                    ev = evunique(idx);
                    subbasis = basis.x(1:end, basis.eigenvalues == ev);
                    tilebasis = basis.x(tile, basis.eigenvalues == ev);
                    [~, num] = size(tilebasis);
                    syms <span class="string">v</span> <span class="string">[num 1]</span>
                    new = tilebasis*v;
                    <span class="keyword">if</span> curr &gt; 0
                        sol = solve([simplify(result{1}(tile,1:curr)'* new == zeros([curr,1])), simplify(norm(new)^2 == 1)], v);
                    <span class="keyword">else</span>
                        sol = vpasolve(simplify(norm(new)^2 == 1), v);
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> isempty(sol)
                        evunique(idx) = [];
                    <span class="keyword">else</span>
                        resV = zeros([num 1]);
                        <span class="keyword">if</span> num == 1
                            resV = sol;
                        <span class="keyword">elseif</span> isempty(sol.v1)
                            evunique(idx) = [];
                            <span class="keyword">continue</span>
                        <span class="keyword">else</span>
                            <span class="keyword">for</span> j = 1 : num
                                <span class="keyword">if</span> isfield(sol, strcat(<span class="string">'v'</span>,int2str(j)))
                                    resV(j,1) = sol.(strcat(<span class="string">'v'</span>,int2str(j)))(1,1);
                                <span class="keyword">end</span>
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                        result{1}(1:end, curr+1) = subbasis*resV;
                        result{2}(curr+1) = ev;
                        curr = curr + 1;
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> result{2}(dim) ~= 0
                        <span class="keyword">return</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">%same but using null instead of solve</span>
        <span class="keyword">function</span> result = Spectrum2(basis, tile, limit, varargin)
            [npts, ~] = size(basis.x);
            dim = length(tile);
            result{3} = tile;
            <span class="keyword">if</span> nargin &gt; 3
                evs = varargin{1};
            <span class="keyword">end</span>
            <span class="keyword">for</span> i = 1:limit
                <span class="keyword">if</span> nargin &gt; 3
                    evs = evs(randperm(length(evs)));
                <span class="keyword">end</span>
                evunique = unique(basis.eigenvalues);
                result{1} = zeros([npts, dim]);
                result{2} = zeros([1 dim]);
                curr = 0;
                counter = 0;
                <span class="keyword">while</span> not(isempty(evunique) || (nargin &gt; 3 &amp;&amp; counter == length(evs)))
                    <span class="keyword">if</span> nargin &gt; 3
                        ev = evs(curr+1);
                        evactual = basis.eigenvalues(abs(basis.eigenvalues - ev)&lt;0.01);
                        ev = evactual(1);
                    <span class="keyword">else</span>
                        idx = randi(length(evunique));
                        ev = evunique(idx);
                    <span class="keyword">end</span>
                    subbasis = basis.x(1:end, basis.eigenvalues == ev);
                    tilebasis = basis.x(tile, basis.eigenvalues == ev);
                    [~, num] = size(tilebasis);
                    syms <span class="string">v</span> <span class="string">[num 1]</span>
                    new = tilebasis*v;
                    <span class="keyword">if</span> curr &gt; 0
                        [A,~] = equationsToMatrix(result{1}(tile,1:curr)'* new == zeros([curr,1]), v);
                        sol = null(A);
                        <span class="keyword">if</span> isempty(sol)
                            evunique(evunique == ev) = [];
                        <span class="keyword">else</span>
                            [~, nsp] = size(sol);
                            order = randperm(nsp);
                            <span class="keyword">for</span> k = 1:nsp
                                vec = subbasis*sol(1:end,order(k));
                                <span class="keyword">if</span> vec(tile,1) == zeros([dim 1])
                                    <span class="keyword">if</span> k == nsp
                                        evunique(evunique == ev) = [];
                                    <span class="keyword">end</span>
                                    <span class="keyword">continue</span>
                                <span class="keyword">else</span>
                                    result{1}(1:end, curr+1) = vec;
                                    result{2}(curr+1) = ev;
                                    curr = curr + 1;
                                    <span class="keyword">break</span>
                                <span class="keyword">end</span>
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">else</span>
<span class="comment">                        %{
</span><span class="comment">                        sol = vpasolve(simplify(norm(new)^2 == 1), v);
</span><span class="comment">                        resV = zeros([num 1]);
</span><span class="comment">                        if num == 1
</span><span class="comment">                            resV = sol;
</span><span class="comment">                        elseif isempty(sol.v1)
</span><span class="comment">                            evunique(evunique == ev) = [];
</span><span class="comment">                            continue
</span><span class="comment">                        else
</span><span class="comment">                            for j = 1 : num
</span><span class="comment">                                if isfield(sol, strcat('v',int2str(j)))
</span><span class="comment">                                    resV(j,1) = sol.(strcat('v',int2str(j)))(1,1);
</span><span class="comment">                                end
</span><span class="comment">                            end
</span><span class="comment">                        end
</span><span class="comment">                        %}
</span>                        resV = zeros([num 1]);
                        resV(1,1) = 1;
                        result{1}(1:end, curr+1) = subbasis*resV;
                        result{2}(curr+1) = ev;
                        curr = curr + 1;

                    <span class="keyword">end</span>
                    <span class="keyword">if</span> result{2}(dim) ~= 0
                        <span class="keyword">return</span>
                    <span class="keyword">end</span>
                    counter = counter + 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

  Orthonormal with no properties.

</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef Orthonormal
    
    methods(Static)
        function check = Test(spectrum, details)
            %TEST(s,d) returns 1 if the set of functions s (formatted as a result
            %of functions below) is an orthogonal spectrum with the given
            %eigenvalues
            mat = double(spectrum{1}(spectrum{3}, 1:end)'*spectrum{1}(spectrum{3}, 1:end));
            %orth = norm(mat - eye(length(spectrum{3}))) < 0.1;
            orth = norm(mat - diag(diag(mat))) < 0.1 && rank(mat) == length(mat);
            eigen = EF.EigenfunctionsCheck(spectrum{1}', spectrum{2}');
            if details
                disp(["orthogonal:",orth])
                disp(mat)
                disp(["eigenfunctions:", eigen]) 
            end
            check = orth && eigen;
        end
        
        %the spectrum searching functions below have the same
        %specifications as FindSpectrum
        %choose set of eigenvalues randomly, solve
        function result = FindSpectrum(basis, tile, limit, numerical, varargin)
            %FINDSPECTRUM(b, t, l, n) returns an orthogonal spectrum of the
            %subset (i.e., set of points) t of the  SG approximations given by b.
            %l specifies the number of attempts to solve for the spectrum.
            %If n is set to true, equations are solved numerically.
            %The output is a cell array where the first entry conatins the
            %matrix of eigenfunctions, the second enrty is the row vector
            %of eigenvalues, the third entry is t.
            w = waitbar(0,mat2str(tile));
            if numerical
                digits(4)
            end
            dim = length(basis.eigenvalues);
            sdim = length(tile);
            syms P [dim dim];
            assume(P, 'real')
            indep = ones([dim, dim]);
            for i = 1:dim
                for j = 1 : i
                    if basis.eigenvalues(i) ~= basis.eigenvalues(j)
                        indep(i,j) = 0;
                        indep(j,i) = 0;
                    end
                end
            end
            new = (basis.x)*(P.*indep);
            for n = 1:limit
                waitbar(n/limit,w);
                chosen = randperm(dim, sdim);
                subnew = new(tile, chosen);
                conditions = [];
                if nargin == 5
                    syms u [dim+3 1];
                    for k = 1:sdim
                        conditions = [conditions,subs(varargin{1}, u, new(1:end,chosen(k)))];
                    end
                end
                if numerical
                    eqa = vpa(subnew'*subnew == eye(sdim));
                    sol = vpasolve([reshape(eqa, [1, sdim^2]), conditions]);
                else
                    eqa = vpa(simplify(subnew'*subnew == eye(sdim)));
                    sol = solve([reshape(eqa, [1, sdim^2]),conditions]);
                end
                resP = zeros([dim dim]);
                for i = 1 : dim
                    for j = 1 : dim
                        if isfield(sol, strcat('P',int2str(i),'_',int2str(j))) && not(isempty(sol.(strcat('P',int2str(i),'_',int2str(j)))))
                            resP(i,j) = subs(sol.(strcat('P',int2str(i),'_',int2str(j)))(1,1), P, zeros([dim dim]));
                        else
                            resP(i, j) = 0;
                        end
                    end
                end
                if resP == zeros([dim dim])
                    continue
                else
                    orthB = (basis.x)*(resP.*indep);
                    orth = orthB(1:end,chosen);
                    eigenvalues = basis.eigenvalues(chosen);
                    result = {orth, eigenvalues, tile};
                    digits(32)
                    close(w);
                    return
                end
            end
            digits(32)
            result = {};
            close(w);
        end
        
        %same but with parallel
        function result = FindSpectrumPar(basis, tile, limit,numerical)
            if numerical
                digits(4)
            else
            digits(32)
            end
            results = [];
            dim = length(basis.eigenvalues);
            sdim = length(tile);
            indep = ones([dim, dim]);
            for i = 1:dim
                for j = 1 : i
                    if basis.eigenvalues(i) ~= basis.eigenvalues(j)
                        indep(i,j) = 0;
                        indep(j,i) = 0;
                    end
                end
            end
            syms P [dim dim];
            assume(P, 'real')
            new = (basis.x)*(P.*indep);
            tilenew = new(tile, 1:end);
            eqa = vpa(simplify(tilenew'*tilenew == eye(dim)));
            parfor n = 1:limit
                chosen = randperm(dim, sdim);
                subeqa = eqa(chosen, chosen);
                if numerical
                    sol = vpasolve(reshape(subeqa, [1, sdim^2]));
                else
                    sol = solve(reshape(subeqa, [1, sdim^2]));
                end
                resP = zeros([dim dim]);
                for i = 1 : dim
                    for j = 1 : dim
                        if isfield(sol, strcat('P',int2str(i),'_',int2str(j))) && not(isempty(sol.(strcat('P',int2str(i),'_',int2str(j)))))
                            vary = symvar(sol.(strcat('P',int2str(i),'_',int2str(j)))(1,1))
                            l = length(vary)
                            resP(i,j) = subs(sol.(strcat('P',int2str(i),'_',int2str(j)))(1,1), vary, zeros([1 l]));%sol.(strcat('P',int2str(i),'_',int2str(j)))(1,1)
                        else
                            resP(i, j) = 0;
                        end
                    end
                end
                if resP == zeros([dim dim])
                    continue
                else
                    orthB = (basis.x)*(resP.*indep);
                    orth = orthB(1:end,chosen);
                    eigenvalues = basis.eigenvalues(chosen);
                    result = {orth, eigenvalues, tile};
                    results = [results,{result}];
                end
            end
            digits(32)
            if not(isempty(results))
                result = results(1);
                result = result{1};
            else
                result = {};
            end
        end
        
        %try adding vetors one by one choosing random eigenvalue each time
        function result = Spectrum(basis, tile, limit)
            [npts, ~] = size(basis.x);
            dim = length(tile);
            result{3} = tile;
            for i = 1:limit
                evunique = unique(basis.eigenvalues);
                result{1} = zeros([npts, dim]);
                result{2} = zeros([1 dim]);
                curr = 0;
                while not(isempty(evunique))
                    idx = randi(length(evunique));
                    ev = evunique(idx);
                    subbasis = basis.x(1:end, basis.eigenvalues == ev);
                    tilebasis = basis.x(tile, basis.eigenvalues == ev);
                    [~, num] = size(tilebasis);
                    syms v [num 1]
                    new = tilebasis*v;
                    if curr > 0
                        sol = solve([simplify(result{1}(tile,1:curr)'* new == zeros([curr,1])), simplify(norm(new)^2 == 1)], v);
                    else
                        sol = vpasolve(simplify(norm(new)^2 == 1), v);
                    end
                    if isempty(sol)
                        evunique(idx) = [];
                    else
                        resV = zeros([num 1]);
                        if num == 1
                            resV = sol;
                        elseif isempty(sol.v1)
                            evunique(idx) = [];
                            continue
                        else
                            for j = 1 : num
                                if isfield(sol, strcat('v',int2str(j)))
                                    resV(j,1) = sol.(strcat('v',int2str(j)))(1,1);
                                end
                            end
                        end
                        result{1}(1:end, curr+1) = subbasis*resV;
                        result{2}(curr+1) = ev;
                        curr = curr + 1;
                    end
                    if result{2}(dim) ~= 0
                        return
                    end
                end
            end
        end
        
        %same but using null instead of solve
        function result = Spectrum2(basis, tile, limit, varargin)
            [npts, ~] = size(basis.x);
            dim = length(tile);
            result{3} = tile;
            if nargin > 3 
                evs = varargin{1};
            end
            for i = 1:limit
                if nargin > 3
                    evs = evs(randperm(length(evs)));
                end
                evunique = unique(basis.eigenvalues);
                result{1} = zeros([npts, dim]);
                result{2} = zeros([1 dim]);
                curr = 0;
                counter = 0;
                while not(isempty(evunique) || (nargin > 3 && counter == length(evs)))
                    if nargin > 3
                        ev = evs(curr+1);
                        evactual = basis.eigenvalues(abs(basis.eigenvalues - ev)<0.01);
                        ev = evactual(1);
                    else
                        idx = randi(length(evunique));
                        ev = evunique(idx);
                    end
                    subbasis = basis.x(1:end, basis.eigenvalues == ev);
                    tilebasis = basis.x(tile, basis.eigenvalues == ev);
                    [~, num] = size(tilebasis);
                    syms v [num 1]
                    new = tilebasis*v;
                    if curr > 0
                        [A,~] = equationsToMatrix(result{1}(tile,1:curr)'* new == zeros([curr,1]), v);
                        sol = null(A);
                        if isempty(sol)
                            evunique(evunique == ev) = [];
                        else
                            [~, nsp] = size(sol);
                            order = randperm(nsp);
                            for k = 1:nsp
                                vec = subbasis*sol(1:end,order(k));
                                if vec(tile,1) == zeros([dim 1])
                                    if k == nsp
                                        evunique(evunique == ev) = [];
                                    end
                                    continue
                                else
                                    result{1}(1:end, curr+1) = vec;
                                    result{2}(curr+1) = ev;
                                    curr = curr + 1;
                                    break
                                end
                            end
                        end
                    else
                        %{
                        sol = vpasolve(simplify(norm(new)^2 == 1), v);
                        resV = zeros([num 1]);
                        if num == 1
                            resV = sol;
                        elseif isempty(sol.v1)
                            evunique(evunique == ev) = [];
                            continue
                        else
                            for j = 1 : num
                                if isfield(sol, strcat('v',int2str(j)))
                                    resV(j,1) = sol.(strcat('v',int2str(j)))(1,1);
                                end
                            end
                        end
                        %}
                        resV = zeros([num 1]);
                        resV(1,1) = 1;
                        result{1}(1:end, curr+1) = subbasis*resV;
                        result{2}(curr+1) = ev;
                        curr = curr + 1;
                       
                    end
                    if result{2}(dim) ~= 0
                        return
                    end
                    counter = counter + 1;
                end
            end
        end
    end
end


##### SOURCE END #####
--></body></html>